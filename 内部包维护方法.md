# 内部包维护方法
内部包维护指的是, 开发过程中常用的代码和包, 应当组织起来, 提高复用程度.  
目前代码复用存在的问题, 主要在于常用包分散于各个具体的项目中, 不利于集中维护.  
如, 阅兵保障项目中开发的/utils包, 可以复用在b2c项目中, 
目前的做法是手动从阅兵保障项目中拷贝/utils包到b2c项目中.  
在两个项目分别开发过程中, 其中一个项目/utils包的修改, 不能同步到另一个项目中, 
当要维护的项目过多时, /utils包的不一致必定越来越多, 而且维护人员也难以区分哪个/utils包中的代码更新, 
哪个包中的代码更稳定, 哪个包中的代码更丰富更齐全了.  
所以将/utils这样的复用率较高的包单独拎出来维护是有必要的.  


有三种维护方案:  
* 第一种, 使用内网svn  
使用内网svn能一定程度上提高共同维护的效率, 但是我们的生产项目也是使用svn进行版本管理, 
当/utils包更新后, 还有单独用svn拉取下来, 放在生产项目的具体目录里.  

* 第二种, 使用外网github, gitlab等  
使用外网github, gitlab首先不符合公司保密要求, `go get`配置私有库也过于麻烦.  

* 第三中, 使用内网gitlab
一个gitlab平台已经搭建在http://192.168.1.195:8011, 可以进行代码管理.  
并且已经上传了一个示例项目http://192.168.1.195:8011/chenzhongrun/utils  
我们需要做的, 是令`go get`命令支持我们的内网平台.  
由于Go原生只支持github, gitlab, gitee等平台, 所以我们需要简单修改Go的源码,
以支持我们搭建的内网平台.  

## 修改Go源码以支持内网git平台
### Step-1 添加自定义平台的支持
#### 以 *go 1.12* 为例
要使`go get`支持内网平台, 只需修改`$GOROOT$\src\cmd\go\internal\get\vcs.go`文件, 
文件970~1000行处(不同版本略有差异, 寻找代码具体位置可以搜索)有如下代码:  
```go
// vcsPaths defines the meaning of import paths referring to
// commonly-used VCS hosting sites (github.com/user/dir)
// and import paths referring to a fully-qualified importPath
// containing a VCS type (foo.com/repo.git/dir)
var vcsPaths = []*vcsPath{
	// Github
	{
		prefix: "github.com/",
		re:     `^(?P<root>github\.com/[A-Za-z0-9_.\-]+/[A-Za-z0-9_.\-]+)(/[\p{L}0-9_.\-]+)*$`,
		vcs:    "git",
		repo:   "https://{root}",
		check:  noVCSSuffix,
	},

	// Bitbucket
	{
		prefix: "bitbucket.org/",
		re:     `^(?P<root>bitbucket\.org/(?P<bitname>[A-Za-z0-9_.\-]+/[A-Za-z0-9_.\-]+))(/[A-Za-z0-9_.\-]+)*$`,
		repo:   "https://{root}",
		check:  bitbucketVCS,
	},

	// IBM DevOps Services (JazzHub)
	{
		prefix: "hub.jazz.net/git/",
		re:     `^(?P<root>hub\.jazz\.net/git/[a-z0-9]+/[A-Za-z0-9_.\-]+)(/[A-Za-z0-9_.\-]+)*$`,
		vcs:    "git",
		repo:   "https://{root}",
		check:  noVCSSuffix,
	},

	// Git at Apache
	{
		prefix: "git.apache.org/",
		re:     `^(?P<root>git\.apache\.org/[a-z0-9_.\-]+\.git)(/[A-Za-z0-9_.\-]+)*$`,
		vcs:    "git",
		repo:   "https://{root}",
	},

	// Git at OpenStack
	{
		prefix: "git.openstack.org/",
		re:     `^(?P<root>git\.openstack\.org/[A-Za-z0-9_.\-]+/[A-Za-z0-9_.\-]+)(\.git)?(/[A-Za-z0-9_.\-]+)*$`,
		vcs:    "git",
		repo:   "https://{root}",
	},

	// chiselapp.com for fossil
	{
		prefix: "chiselapp.com/",
		re:     `^(?P<root>chiselapp\.com/user/[A-Za-z0-9]+/repository/[A-Za-z0-9_.\-]+)$`,
		vcs:    "fossil",
		repo:   "https://{root}",
	},

	// 此处增加一个我们要定制化的平台的生成语法
	// General syntax for custom server
	{
		prefix: os.Getenv("CUSTOMVCSPREFIX") + "/", // e.g. CUSTOMVCSPREFIX=golang.mycompany.com
		re:     fmt.Sprintf(`^(?P<root>%s(?P<p>[A-Za-z0-9_.\-]+/[A-Za-z0-9_.\-]+))(/[A-Za-z0-9_.\-]+)*$`, strings.ReplaceAll(os.Getenv("CUSTOMVCSPREFIX")+"/", ".", "\\.")),
		vcs: "git",
		epo:  "http://" + os.Getenv("CUSTOMVCSADDRESS") + "/{p}", // e.g. CUSTOMVCSADDRESS=192.168.1.195:8011
		ping:  false,
		check: noVCSSuffix,
    },

	// General syntax for any server.
	// Must be last.
	{
		re:   `^(?P<root>(?P<repo>([a-z0-9.\-]+\.)+[a-z0-9.\-]+(:[0-9]+)?(/~?[A-Za-z0-9_.\-]+)+?)\.(?P<vcs>bzr|fossil|git|hg|svn))(/~?[A-Za-z0-9_.\-]+)*$`,
		ping: true,
	},
}
```   
可以看到, `vcsPaths`变量维护了`go get`所支持的站点和平台, 我们在最后增加了`General syntax for custom server`, 
用来生成定制化平台的支持.  
这样, 设置`CUSTOMVCSPREFIX`为`golang.helowin.com`, `CUSTOMVCSADDRESS`为`192.168.1.195:8011`, 
当我们`go get -v -u -insecure golang.helowin.com/go-gateway/utils`时, 
实际fetch的代码库地址是`http://192.168.1.195:8011/go-gateway/utils`.  
代码库会下载到`$GOPATH$/src/golang.helowin.com/go-gateway/utils`.  
的支持.  将`golang.helowin.com/{path}`的包指向`http://192.168.1.195:8011/{p}`.  

#### *go 1.13* 略有不同
go 1.13的不同之处在于`re`字段换成了`regexp`, 并且用`lazyregexp.New()`编译了正则表达式.  
```go
    /*...*/
	// General syntax for custom server
	{
		prefix: os.Getenv("CUSTOMVCSPREFIX") + "/", // e.g. CUSTOMVCSPREFIX=golang.mycompany.com
		regexp: lazyregexp.New(fmt.Sprintf(`^(?P<root>%s(?P<p>[A-Za-z0-9_.\-]+/[A-Za-z0-9_.\-]+))(/[A-Za-z0-9_.\-]+)*$`,
			strings.ReplaceAll(os.Getenv("CUSTOMVCSPREFIX")+"/", ".", "\\."))),
		vcs:   "git",
		repo:  "http://" + os.Getenv("CUSTOMVCSADDRESS") + "/{p}", // e.g. CUSTOMVCSADDRESS=192.168.1.195:8011
		ping:  false,
		check: noVCSSuffix,
	},
/*...*/
```

#### 使用*`func() *vcsPath {}`*表达复杂逻辑
如果要对prefix和path进行比较复杂的处理, 可以使用函数, 如:  
```go
    /*...*/
	// General syntax for custom server
	func() *vcsPath {
		prefix := os.Getenv("CUSTOMVCSPREFIX") + "/" // e.g. "golang.helowin.com/"
		address := os.Getenv("CUSTOMVCSADDRESS")
		if prefix == "" || address == "" {
			return &vcsPath{
				re:   `^(?P<root>(?P<repo>([a-z0-9.\-]+\.)+[a-z0-9.\-]+(:[0-9]+)?(/~?[A-Za-z0-9_.\-]+)+?)\.(?P<vcs>bzr|fossil|git|hg|svn))(/~?[A-Za-z0-9_.\-]+)*$`,
				ping: true,
			}
		}
		return &vcsPath{
			prefix: prefix,
			re:     fmt.Sprintf(`^(?P<root>%s(?P<p>[A-Za-z0-9_.\-]+/[A-Za-z0-9_.\-]+))(/[A-Za-z0-9_.\-]+)*$`, strings.Join(strings.Split(prefix, "."), "\\.")),
			vcs:    "git",
			repo:   "http://" + address + "/{p}",
			ping:   false,
			check:  noVCSSuffix,
		}
	}(),
/*...*/
```  
这里把原来的把原来的`General syntax for any server`删掉了, 合并在`General syntax for custom server`
这里函数里. 意思是, 当我们设置了定制服务器环境变量时, 就覆盖掉原来的`General syntax for any server`, 
当我们没有设置定制服务器环境变量时, 就还用原生的办法支持其他服务器. 这只是一个简单的例子.    

#### 注意:
字段`ping`的值为false


### Step-2 定制平台合法性检查
另外还需修改一个函数, 这个函数检查前缀和路径的合法性. 
```go
// pathPrefix reports whether sub is a prefix of s,
// only considering entire path components.
func pathPrefix(s, sub string) bool {
	// strings.HasPrefix is necessary but not sufficient.
	if !strings.HasPrefix(s, sub) {
		return false
	}
	// The remainder after the prefix must either be empty or start with a slash. 
	// if there is ":{port}" between prefix and remainder, trim it
	rem := s[len(sub):]
	//return rem == "" || rem[0] == '/'
	return rem == "" || rem[0] == '/' || (rem[0] == ':' && pathPrefix(strings.TrimLeftFunc(strings.TrimPrefix(rem, ":"), func(r rune) bool {
		return unicode.IsNumber(r)
	}), ""))
}
```  
函数原来的功能是, 如输入`go get github.com/micro/micro`, 函数会以`go get github.com/micro/micro`去掉
meta tag `go get github.com`, 剩下`/micro/micro`, 检查剩下的部分是否为空或是否以`/`开头.  
但是我们输入`go get golang.helowin.com/go-gateway/utils`时, 实际fetch的是对应的IP地址+路径, 如
`192.168.1.195:8011/go-gateway/utils`, 去掉程序获取到的meta tag `192.168.1.195`后, 剩下的部分是
`:8011/go-gateway/utils`, 既不为空也不以`/`开头, 被判为不合法.  
所以增加了一种合法的情况, 以支持我们这种`{ip}:{port}/{path}`域名的情况:
```go
rem[0] == ':' && pathPrefix(strings.TrimLeftFunc(strings.TrimPrefix(rem, ":"), func(r rune) bool {
		return unicode.IsNumber(r)
	}), "")
```

### Step-3 编译安装
修改完成之后, 需要重新编译go.exe可执行文件(记得备份原来的go可执行文件).  
```cmd
$GOROOT$\src\cmd\go>> go install
```

## 用`go get`安装内网gitlab平台上的包
### 安装
在我们的项目中打开命令行窗口.  
首先要设置环境变量.  `CUSTOMVCSPREFIX=golang.helowin.com CUSTOMVCSADDRESS=192.168.1.195`可以设置在系统或用户环境变量里, 
也可以在命令行里临时设置.  我们使用的是内网平台, 所以不需要代理, 代理反而不通, 设置`GOPROXY=direct`为直连.   
```cmd
>>export CUSTOMVCSPREFIX=golang.helowin.com CUSTOMVCSADDRESS=192.168.1.195 GOPROXY=direct   # 可以提前设置好全局环境变量, powershell中用set设置
>>go get -v -u -insecure golang.helowin.com/go-gateway/utils # -insecure表示不进行https检查, 以兼容我们的http服务器

  go: finding golang.helowin.com/go-gateway/utils v0.1.3
  go: downloading golang.helowin.com/go-gateway/utils v0.1.3
  go: extracting golang.helowin.com/go-gateway/utils v0.1.3
  golang.helowin.com/go-gateway/utils
```
进入`$GOPATH$`, 可以看到`$GOPATH$/src/golang.helowin.com/go-gateway/utils`已经存在.  
采用GO111MODULE(GOMOD)模式时可以在对应的mod目录下查看.  

### 使用
```go
package somepackage

import (
    "golang.helowin.com/chenzhongrun/utils/log"
)

func somefunc() {
	log.Infoln("success")
} 

``` 

## 企业内部包的管理
### Step-1 加入群组
加入包维护群组, 如`http://192.168.1.195/go-gateway`网关组.  

### Step-2 维护项目
拉取项目, 如`http://192.168.1.195/go-gateway/utils`;  
修改项目;  
提交和推送项目.  
目前开发人员较少, 不采用PR模式, 可以直接推送到主分支, 各人对自己的提交负责.  

### Step-3 添加版本标签
有重要的修改, 可以为版本打上tag, 如:
```cmd
>> git tag v0.1.4
>> git push origin v0.1.4
```
包的使用者就可以更新版本了:
```cmd
>> go get -v -u -insecure golang.helowin.com/go-gateway/utils
```
如果是GOModule模式(`GO111MODULE=on`), 还可以指定版本, 
```cmd
>> go get -v -u -insecure golang.helowin.com/go-gateway/utils@v0.1.4
```

## 可选修改
*$GOROOT$/src/cmd/go/internal/envcmd/env.go*
```go
func MkEnv() []cfg.EnvVar {
	/*...*/
	env := []cfg.EnvVar{
		{Name: "GO111MODULE", Value: cfg.Getenv("GO111MODULE")},
		...
		{Name: "CUSTOMVCSPREFIX", Value: os.Getenv("CUSTOMVCSPREFIX")}, //增加的行
		{Name: "CUSTOMVCSADDRESS", Value: os.Getenv("CUSTOMVCSADDRESS")},   //增加的行
	}
	/*...*/
}
```
重新编译安装后, 在命令行中输入`go env`可以查看`CUSTOMVCSPREFIX`和`CUSTOMVCSADDRESS`两个环境变量.  
```cmd
>> go env
  GOARCH="amd64"
  GOHOSTARCH="amd64"
  GOHOSTOS="linux"
  ...
  CUSTOMVCSPREFIX="golang.helowin.com"
  CUSTOMVCSADDRESS="192.168.1.195:8011"
  ...
```
这个修改不是必要的.  


## 缺点
### 不能使用`go mod download`
由于go mod模式不支持http服务器, 所以不能使用`go mod download`下载
